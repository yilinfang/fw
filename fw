#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
import tempfile
from shutil import which
from typing import List, Optional


def check_tool(tool_name: str) -> bool:
    """Check if a tool is installed by checking its path."""
    return which(tool_name) is not None


def is_binary(file_path: str) -> bool:
    """Check if a file is binary by looking for null bytes in the first block."""
    try:
        with open(file_path, "rb") as f:
            chunk = f.read(1024)
            return b"\x00" in chunk
    except Exception:
        return True


def get_file_lister() -> Optional[str]:
    """Determine the best available file listing tool."""
    for tool in ["fd", "fdfind", "rg", "find"]:
        if check_tool(tool):
            return tool
    return None


def get_previewer() -> Optional[str]:
    """Determine the best available file previewing tool."""
    for tool in ["bat", "cat"]:
        if check_tool(tool):
            return tool
    return None


def build_file_list_command(
    lister: str, directory: str, hidden: bool, no_ignore: bool
) -> List[str]:
    """Build the command to list files based on the available tool."""
    if lister in ["fd", "fdfind"]:
        cmd = [lister, "--type", "f", "--exclude", ".git", ".", directory]
        if hidden:
            cmd.append("--hidden")
        if no_ignore:
            cmd.append("--no-ignore")
        return cmd
    if lister == "rg":
        cmd = ["rg", "--files", "--glob", "!.git/*"]
        if hidden:
            cmd.append("--hidden")
        if no_ignore:
            cmd.append("--no-ignore")
        cmd.append(directory)
        return cmd
    # Fallback to find
    cmd = ["find", directory, "-path", "*/.git", "-prune", "-o", "-type", "f"]
    if not hidden:
        cmd.extend(["-not", "-path", "*/.*"])
    cmd.append("-print")
    return cmd


def get_preview_command(previewer: str) -> str:
    """Get the appropriate preview command for fzf."""
    if previewer == "bat":
        return "bat --color=always --paging=never --style=plain --line-range=:150 {}"
    return "cat {} | head -n 500"


def run_fzf(file_list: List[str], preview_cmd: str) -> List[str]:
    """Run fzf with a preview command and return selected files."""
    try:
        result = subprocess.run(
            ["fzf", "--multi", "--preview", preview_cmd],
            input="\n".join(file_list),
            text=True,
            capture_output=True,
            check=False,
        )
        if result.returncode == 0:
            return [f.strip() for f in result.stdout.split("\n") if f.strip()]
        if result.returncode == 130:
            print("Selection aborted by user.")
            return []
        return []
    except Exception as e:
        print(f"Error running fzf: {e}", file=sys.stderr)
        sys.exit(1)


def combine_files(
    selected_files: List[str], output_file: str, base_directory: str
) -> None:
    """Combine selected files into the output file with metadata markers."""
    try:
        with open(output_file, "w", encoding="utf-8") as f:
            for file_path in selected_files:
                if not os.path.isfile(file_path):
                    continue

                try:
                    rel_path = os.path.relpath(file_path, base_directory)
                except ValueError:
                    rel_path = file_path

                f.write(f"<<< START OF FILE: {rel_path} >>>\n")
                try:
                    with open(
                        file_path, "r", encoding="utf-8", errors="replace"
                    ) as infile:
                        f.write(infile.read())
                except Exception as e:
                    f.write(f"Error reading file {rel_path}: {e}\n")
                f.write(f"\n<<< END OF FILE: {rel_path} >>>\n\n")
    except Exception as e:
        print(f"Error writing to {output_file}: {e}", file=sys.stderr)
        sys.exit(1)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Interactive file selector and combiner for AI context."
    )
    parser.add_argument("directory", nargs="?", default=".", help="Target directory.")
    parser.add_argument(
        "-H", "--hidden", action="store_true", help="Include hidden files."
    )
    parser.add_argument(
        "-I", "--no-ignore", action="store_true", help="Ignore VCS rules."
    )
    parser.add_argument("-O", "--output", type=str, help="Output file path.")
    args = parser.parse_args()

    if not check_tool("fzf"):
        print("Error: fzf is required but not installed.", file=sys.stderr)
        sys.exit(1)

    directory = os.path.abspath(args.directory)
    if not os.path.isdir(directory):
        print(f"Error: '{directory}' is not a directory.", file=sys.stderr)
        sys.exit(1)

    if sys.stdin.isatty():
        lister = get_file_lister()
        if not lister:
            print("Error: No file lister (fd, rg, find) found.", file=sys.stderr)
            sys.exit(1)

        lister_cmd = build_file_list_command(
            lister, directory, args.hidden, args.no_ignore
        )
        try:
            result = subprocess.run(
                lister_cmd, capture_output=True, text=True, check=True
            )
            raw_files = result.stdout.strip().splitlines()
            # Filter out binary files for a cleaner selection
            file_list = [f for f in raw_files if not is_binary(f)]
        except subprocess.CalledProcessError as e:
            print(f"Error listing files: {e.stderr}", file=sys.stderr)
            sys.exit(1)
    else:
        file_list = [line.strip() for line in sys.stdin if line.strip()]

    if not file_list:
        print("No files found.")
        return

    preview_cmd = os.getenv("FW_PREVIEW_CMD") or get_preview_command(
        get_previewer() or "none"
    )
    selected_files = run_fzf(file_list, preview_cmd)

    if not selected_files:
        return

    output_path = args.output
    is_temp = not output_path

    if is_temp:
        fd, output_path = tempfile.mkstemp(prefix="fw_", suffix=".txt")
        os.close(fd)

    combine_files(selected_files, output_path, directory)
    print(f"Combined {len(selected_files)} files into {output_path}")

    editor = os.getenv("EDITOR") or os.getenv("VISUAL") or "vi"
    try:
        subprocess.run([editor, output_path], check=True)
    except Exception as e:
        print(f"Could not open editor: {e}", file=sys.stderr)

    if is_temp:
        try:
            os.remove(output_path)
        except OSError:
            pass


if __name__ == "__main__":
    main()
