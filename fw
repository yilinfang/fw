#!/usr/bin/env python3
"""
fw - File selector and combiner for AI context.

A lightweight CLI tool that allows users to interactively select files using fzf
or skim, preview their contents, and combine them into a single output file
ready for pasting into AI assistants like ChatGPT or Claude.
"""

import argparse
import os
import shlex
import shutil
import subprocess
import sys
import tempfile
from shutil import which
from typing import List, Optional

__version__ = "1.4.0"


def check_tool(tool_name: str) -> bool:
    """Check if a tool is installed by checking its path.

    Args:
        tool_name: Name of the command-line tool to check.

    Returns:
        True if the tool is found in PATH, False otherwise.
    """
    return which(tool_name) is not None


def get_file_lister() -> Optional[str]:
    """Determine the best available file listing tool.

    Returns:
        Name of the available tool (fd, fdfind, rg, or find), or None if none found.
    """
    for tool in ["fd", "fdfind", "rg", "find"]:
        if check_tool(tool):
            return tool
    return None


def get_previewer() -> Optional[str]:
    """Determine the best available file previewing tool.

    Returns:
        Name of the available tool (bat or cat), or None if none found.
    """
    for tool in ["bat", "cat"]:
        if check_tool(tool):
            return tool
    return None


def get_fuzzy_finder() -> Optional[str]:
    """Determine the best available fuzzy finder tool.

    Returns:
        Name of the available tool (fzf or sk), or None if none found.
    """
    for tool in ["fzf", "sk"]:
        if check_tool(tool):
            return tool
    return None


def build_file_list_command(
    lister: str, directory: str, hidden: bool, no_ignore: bool
) -> List[str]:
    """Build the command to list files based on the available tool.

    Args:
        lister: Name of the file listing tool to use.
        directory: Directory to search in.
        hidden: Whether to include hidden files.
        no_ignore: Whether to ignore .gitignore rules.

    Returns:
        List of command arguments to execute.
    """
    if lister in ["fd", "fdfind"]:
        cmd = [lister, "--type", "f", "--exclude", ".git", ".", directory]
        if hidden:
            cmd.append("--hidden")
        if no_ignore:
            cmd.append("--no-ignore")
        return cmd
    if lister == "rg":
        cmd = ["rg", "--files", "--glob", "!.git/*"]
        if hidden:
            cmd.append("--hidden")
        if no_ignore:
            cmd.append("--no-ignore")
        cmd.append(directory)
        return cmd
    # Fallback to find
    cmd = ["find", directory, "-path", "*/.git", "-prune", "-o", "-type", "f"]
    if not hidden:
        cmd.extend(["-not", "-path", "*/.*"])
    cmd.append("-print")
    return cmd


def get_preview_command(previewer: str) -> str:
    """Get the appropriate preview command for fzf.

    Args:
        previewer: Name of the previewer tool (bat or cat).

    Returns:
        Preview command string for fzf.
    """
    if previewer == "bat":
        return "bat --color=always --paging=never --style=plain --line-range=:150 {}"
    return "cat {} | head -n 500"


def run_fzf(fzf_cmd: str, file_list: List[str], preview_cmd: str) -> List[str]:
    """Run fzf with a preview command and return selected files.

    Args:
        fzf_cmd: Command name for the fuzzy finder (fzf or sk).
        file_list: List of file paths to present in fzf.
        preview_cmd: Preview command for fzf to use.

    Returns:
        List of selected file paths, or empty list if selection was cancelled.
    """
    try:
        result = subprocess.run(
            [fzf_cmd, "--multi", "--preview", preview_cmd],
            input="\n".join(file_list),
            text=True,
            capture_output=True,
            check=False,
        )
        if result.returncode == 0:
            return [f.strip() for f in result.stdout.split("\n") if f.strip()]
        if result.returncode == 130:
            return []
        return []
    except Exception as e:
        print(f"Error running fzf: {e}", file=sys.stderr)
        sys.exit(1)


def run_fzf_with_command(
    fzf_cmd: str, lister_cmd: List[str], preview_cmd: str
) -> List[str]:
    """Run a file lister piped directly into fzf, returning selected files.

    Args:
        fzf_cmd: Command name for the fuzzy finder (fzf or sk).
        lister_cmd: Command to list files.
        preview_cmd: Preview command for fzf to use.

    Returns:
        List of selected file paths, or empty list if selection was cancelled.
    """
    try:
        # Capture lister stderr in a real file to avoid deadlocks from PIPE backpressure.
        with tempfile.TemporaryFile(mode="w+t") as lister_stderr_file:
            lister_proc = subprocess.Popen(
                lister_cmd,
                stdout=subprocess.PIPE,
                stderr=lister_stderr_file,
                text=True,
            )
            fzf_proc = subprocess.Popen(
                [fzf_cmd, "--multi", "--preview", preview_cmd],
                stdin=lister_proc.stdout,
                stdout=subprocess.PIPE,
                stderr=None,
                text=True,
            )
            # Allow lister to receive SIGPIPE if fzf exits early
            lister_proc.stdout.close()
            stdout, _ = fzf_proc.communicate()
            lister_returncode = lister_proc.wait()

            lister_stderr_file.seek(0)
            lister_stderr = lister_stderr_file.read().strip()

            # Ignore SIGPIPE-style exits when fzf exits early/cancelled.
            if lister_returncode not in (0, 141, -13) and fzf_proc.returncode != 130:
                if lister_stderr:
                    print(f"Error listing files: {lister_stderr}", file=sys.stderr)
                else:
                    print("Error listing files.", file=sys.stderr)

        if fzf_proc.returncode == 0:
            return [f.strip() for f in stdout.split("\n") if f.strip()]
        return []
    except Exception as e:
        print(f"Error running fzf: {e}", file=sys.stderr)
        sys.exit(1)


def format_size(size_bytes: int) -> str:
    """Format a byte size into a human-readable string.

    Args:
        size_bytes: Size in bytes.

    Returns:
        Human-readable size string (e.g., "1.5 KB", "2.3 MB").
    """
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    else:
        return f"{size_bytes / (1024 * 1024):.1f} MB"


def combine_files(
    selected_files: List[str], output_file: str, base_directory: str
) -> int:
    """Combine selected files into the output file with metadata markers.

    Args:
        selected_files: List of file paths to combine.
        output_file: Path to the output file.
        base_directory: Base directory for computing relative paths.

    Returns:
        Total bytes written to the output file.
    """
    total_bytes = 0
    try:
        with open(output_file, "w", encoding="utf-8") as f:
            for file_path in selected_files:
                if not os.path.isfile(file_path):
                    continue

                try:
                    rel_path = os.path.relpath(file_path, base_directory)
                except ValueError:
                    rel_path = file_path

                f.write(f"<<< START OF FILE: {rel_path} >>>\n")
                try:
                    with open(
                        file_path, "r", encoding="utf-8", errors="replace"
                    ) as infile:
                        shutil.copyfileobj(infile, f)
                except Exception as e:
                    f.write(f"Error reading file {rel_path}: {e}\n")
                f.write(f"\n<<< END OF FILE: {rel_path} >>>\n\n")
        total_bytes = os.path.getsize(output_file)
    except Exception as e:
        print(f"Error writing to {output_file}: {e}", file=sys.stderr)
        sys.exit(1)
    return total_bytes


def get_latest_version() -> Optional[str]:
    """Fetch the latest release tag from GitHub.

    Returns:
        The latest version string (e.g. "1.3.0"), or None on failure.
    """
    import json
    from urllib.request import urlopen
    from urllib.error import URLError

    api_url = "https://api.github.com/repos/yilinfang/fw/releases/latest"
    try:
        with urlopen(api_url) as resp:
            data = json.loads(resp.read().decode())
            return data.get("tag_name", "").lstrip("v") or None
    except (URLError, ValueError, KeyError):
        return None


def self_update() -> None:
    """Update fw to the latest release, skipping if already up to date."""
    latest = get_latest_version()
    if latest is None:
        print("Error: Could not fetch latest version from GitHub.", file=sys.stderr)
        sys.exit(1)

    if latest == __version__:
        print("fw is already up to date ({}).".format(__version__))
        return

    print("Updating fw from {} to {}...".format(__version__, latest))

    script_dir = os.path.dirname(os.path.realpath(sys.argv[0]))
    install_url = "https://raw.githubusercontent.com/yilinfang/fw/main/install.sh"
    env = dict(os.environ, FW_INSTALL_DIR=script_dir)

    if which("curl"):
        fetch_cmd = "curl -fsSL {}".format(install_url)
    elif which("wget"):
        fetch_cmd = "wget -qO- {}".format(install_url)
    else:
        print("Error: Neither curl nor wget found.", file=sys.stderr)
        sys.exit(1)

    try:
        subprocess.run(
            "{} | bash".format(fetch_cmd),
            shell=True,
            check=True,
            env=env,
        )
    except subprocess.CalledProcessError as e:
        print("Error during update: {}".format(e), file=sys.stderr)
        sys.exit(1)


def main() -> None:
    """Main entry point for the fw command."""
    parser = argparse.ArgumentParser(
        description="Interactive file selector and combiner for AI context.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  fw                      Select files from current directory
  fw ~/project            Select files from ~/project
  fw -H                   Include hidden files
  fw -I                   Ignore .gitignore rules
  fw -O out.txt           Save to specific output file
  find . -name "*.py" | fw   Use piped input
        """,
    )
    parser.add_argument("directory", nargs="?", default=".", help="Target directory.")
    parser.add_argument(
        "-H", "--hidden", action="store_true", help="Include hidden files."
    )
    parser.add_argument(
        "-I", "--no-ignore", action="store_true", help="Ignore VCS ignore rules."
    )
    parser.add_argument("-O", "--output", type=str, help="Output file path.")
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Show verbose output."
    )
    parser.add_argument(
        "-V", "--version", action="version", version=f"fw {__version__}"
    )
    parser.add_argument(
        "--self-update", action="store_true", help="Update fw to the latest version."
    )
    args = parser.parse_args()

    if args.self_update:
        self_update()
        return

    fzf_tool = get_fuzzy_finder()
    if not fzf_tool:
        print(
            "Error: fzf or sk (skim) is required but not installed.\n"
            "Install fzf from: https://github.com/junegunn/fzf\n"
            "Or skim from: https://github.com/lotabout/skim",
            file=sys.stderr,
        )
        sys.exit(1)

    directory = os.path.abspath(args.directory)
    if not os.path.isdir(directory):
        print(f"Error: '{directory}' is not a directory.", file=sys.stderr)
        sys.exit(1)

    preview_cmd = os.getenv("FW_PREVIEW_CMD") or get_preview_command(
        get_previewer() or "none"
    )

    if sys.stdin.isatty():
        lister = get_file_lister()
        if not lister:
            print("Error: No file lister (fd, rg, find) found.", file=sys.stderr)
            sys.exit(1)

        lister_cmd = build_file_list_command(
            lister, directory, args.hidden, args.no_ignore
        )
        selected_files = run_fzf_with_command(fzf_tool, lister_cmd, preview_cmd)
    else:
        file_list = [line.strip() for line in sys.stdin if line.strip()]
        if not file_list:
            print("No files found.")
            return
        selected_files = run_fzf(fzf_tool, file_list, preview_cmd)

    if not selected_files:
        return

    output_path = args.output
    is_temp = not output_path

    if is_temp:
        fd, output_path = tempfile.mkstemp(prefix="fw_", suffix=".txt")
        os.close(fd)

    total_bytes = combine_files(selected_files, output_path, directory)

    if args.verbose:
        print(
            f"Combined {len(selected_files)} file(s) ({format_size(total_bytes)}) "
            f"into {output_path}"
        )

    editor = os.getenv("VISUAL") or os.getenv("EDITOR") or "vi"
    editor_success = False
    try:
        editor_cmd = shlex.split(editor)
        if not editor_cmd:
            raise ValueError("editor command is empty")
        subprocess.run([*editor_cmd, output_path], check=True)
        editor_success = True
    except Exception as e:
        print(f"Could not open editor: {e}", file=sys.stderr)
        if is_temp:
            print(f"Combined output preserved at: {output_path}", file=sys.stderr)

    if is_temp and editor_success:
        try:
            os.remove(output_path)
        except OSError:
            pass


if __name__ == "__main__":
    main()
