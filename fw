#!/usr/bin/env python3
"""
fw - File selector and combiner for AI context.

A lightweight CLI tool that allows users to interactively select files using fzf,
preview their contents, and combine them into a single output file ready for
pasting into AI assistants like ChatGPT or Claude.
"""

import argparse
import os
import subprocess
import sys
import tempfile
from shutil import which
from typing import List, Optional

__version__ = "1.0.0"


def check_tool(tool_name: str) -> bool:
    """Check if a tool is installed by checking its path.

    Args:
        tool_name: Name of the command-line tool to check.

    Returns:
        True if the tool is found in PATH, False otherwise.
    """
    return which(tool_name) is not None


def is_binary(file_path: str) -> bool:
    """Check if a file is binary by looking for null bytes in the first block.

    Args:
        file_path: Path to the file to check.

    Returns:
        True if the file appears to be binary, False otherwise.
    """
    try:
        with open(file_path, "rb") as f:
            chunk = f.read(1024)
            return b"\x00" in chunk
    except Exception:
        return True


def get_file_lister() -> Optional[str]:
    """Determine the best available file listing tool.

    Returns:
        Name of the available tool (fd, fdfind, rg, or find), or None if none found.
    """
    for tool in ["fd", "fdfind", "rg", "find"]:
        if check_tool(tool):
            return tool
    return None


def get_previewer() -> Optional[str]:
    """Determine the best available file previewing tool.

    Returns:
        Name of the available tool (bat or cat), or None if none found.
    """
    for tool in ["bat", "cat"]:
        if check_tool(tool):
            return tool
    return None


def build_file_list_command(
    lister: str, directory: str, hidden: bool, no_ignore: bool
) -> List[str]:
    """Build the command to list files based on the available tool.

    Args:
        lister: Name of the file listing tool to use.
        directory: Directory to search in.
        hidden: Whether to include hidden files.
        no_ignore: Whether to ignore .gitignore rules.

    Returns:
        List of command arguments to execute.
    """
    if lister in ["fd", "fdfind"]:
        cmd = [lister, "--type", "f", "--exclude", ".git", ".", directory]
        if hidden:
            cmd.append("--hidden")
        if no_ignore:
            cmd.append("--no-ignore")
        return cmd
    if lister == "rg":
        cmd = ["rg", "--files", "--glob", "!.git/*"]
        if hidden:
            cmd.append("--hidden")
        if no_ignore:
            cmd.append("--no-ignore")
        cmd.append(directory)
        return cmd
    # Fallback to find
    cmd = ["find", directory, "-path", "*/.git", "-prune", "-o", "-type", "f"]
    if not hidden:
        cmd.extend(["-not", "-path", "*/.*"])
    cmd.append("-print")
    return cmd


def get_preview_command(previewer: str) -> str:
    """Get the appropriate preview command for fzf.

    Args:
        previewer: Name of the previewer tool (bat or cat).

    Returns:
        Preview command string for fzf.
    """
    if previewer == "bat":
        return "bat --color=always --paging=never --style=plain --line-range=:150 {}"
    return "cat {} | head -n 500"


def run_fzf(file_list: List[str], preview_cmd: str) -> List[str]:
    """Run fzf with a preview command and return selected files.

    Args:
        file_list: List of file paths to present in fzf.
        preview_cmd: Preview command for fzf to use.

    Returns:
        List of selected file paths, or empty list if selection was cancelled.
    """
    try:
        result = subprocess.run(
            ["fzf", "--multi", "--preview", preview_cmd],
            input="\n".join(file_list),
            text=True,
            capture_output=True,
            check=False,
        )
        if result.returncode == 0:
            return [f.strip() for f in result.stdout.split("\n") if f.strip()]
        if result.returncode == 130:
            return []
        return []
    except Exception as e:
        print(f"Error running fzf: {e}", file=sys.stderr)
        sys.exit(1)


def format_size(size_bytes: int) -> str:
    """Format a byte size into a human-readable string.

    Args:
        size_bytes: Size in bytes.

    Returns:
        Human-readable size string (e.g., "1.5 KB", "2.3 MB").
    """
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    else:
        return f"{size_bytes / (1024 * 1024):.1f} MB"


def get_total_size(file_paths: List[str]) -> int:
    """Calculate the total size of a list of files.

    Args:
        file_paths: List of file paths.

    Returns:
        Total size in bytes.
    """
    total = 0
    for path in file_paths:
        try:
            total += os.path.getsize(path)
        except OSError:
            pass
    return total


def combine_files(
    selected_files: List[str], output_file: str, base_directory: str
) -> None:
    """Combine selected files into the output file with metadata markers.

    Args:
        selected_files: List of file paths to combine.
        output_file: Path to the output file.
        base_directory: Base directory for computing relative paths.
    """
    try:
        with open(output_file, "w", encoding="utf-8") as f:
            for file_path in selected_files:
                if not os.path.isfile(file_path):
                    continue

                try:
                    rel_path = os.path.relpath(file_path, base_directory)
                except ValueError:
                    rel_path = file_path

                f.write(f"<<< START OF FILE: {rel_path} >>>\n")
                try:
                    with open(
                        file_path, "r", encoding="utf-8", errors="replace"
                    ) as infile:
                        f.write(infile.read())
                except Exception as e:
                    f.write(f"Error reading file {rel_path}: {e}\n")
                f.write(f"\n<<< END OF FILE: {rel_path} >>>\n\n")
    except Exception as e:
        print(f"Error writing to {output_file}: {e}", file=sys.stderr)
        sys.exit(1)


def main() -> None:
    """Main entry point for the fw command."""
    parser = argparse.ArgumentParser(
        description="Interactive file selector and combiner for AI context.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  fw                      Select files from current directory
  fw ~/project            Select files from ~/project
  fw -H                   Include hidden files
  fw -I                   Ignore .gitignore rules
  fw -O out.txt           Save to specific output file
  find . -name "*.py" | fw   Use piped input
        """,
    )
    parser.add_argument("directory", nargs="?", default=".", help="Target directory.")
    parser.add_argument(
        "-H", "--hidden", action="store_true", help="Include hidden files."
    )
    parser.add_argument(
        "-I", "--no-ignore", action="store_true", help="Ignore VCS ignore rules."
    )
    parser.add_argument("-O", "--output", type=str, help="Output file path.")
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Show verbose output."
    )
    parser.add_argument(
        "-V", "--version", action="version", version=f"fw {__version__}"
    )
    args = parser.parse_args()

    if not check_tool("fzf"):
        print(
            "Error: fzf is required but not installed.\n"
            "Install it from: https://github.com/junegunn/fzf",
            file=sys.stderr,
        )
        sys.exit(1)

    directory = os.path.abspath(args.directory)
    if not os.path.isdir(directory):
        print(f"Error: '{directory}' is not a directory.", file=sys.stderr)
        sys.exit(1)

    if sys.stdin.isatty():
        lister = get_file_lister()
        if not lister:
            print("Error: No file lister (fd, rg, find) found.", file=sys.stderr)
            sys.exit(1)

        lister_cmd = build_file_list_command(
            lister, directory, args.hidden, args.no_ignore
        )
        try:
            result = subprocess.run(
                lister_cmd, capture_output=True, text=True, check=True
            )
            raw_files = result.stdout.strip().splitlines()
            # Filter out binary files for a cleaner selection
            file_list = [f for f in raw_files if not is_binary(f)]
        except subprocess.CalledProcessError as e:
            print(f"Error listing files: {e.stderr}", file=sys.stderr)
            sys.exit(1)
    else:
        file_list = [line.strip() for line in sys.stdin if line.strip()]

    if not file_list:
        print("No files found.")
        return

    preview_cmd = os.getenv("FW_PREVIEW_CMD") or get_preview_command(
        get_previewer() or "none"
    )
    selected_files = run_fzf(file_list, preview_cmd)

    if not selected_files:
        return

    output_path = args.output
    is_temp = not output_path

    if is_temp:
        fd, output_path = tempfile.mkstemp(prefix="fw_", suffix=".txt")
        os.close(fd)

    combine_files(selected_files, output_path, directory)

    if args.verbose:
        total_size = get_total_size(selected_files)
        print(
            f"Combined {len(selected_files)} file(s) ({format_size(total_size)}) "
            f"into {output_path}"
        )

    editor = os.getenv("EDITOR") or os.getenv("VISUAL") or "vi"
    try:
        subprocess.run([editor, output_path], check=True)
    except Exception as e:
        print(f"Could not open editor: {e}", file=sys.stderr)

    if is_temp:
        try:
            os.remove(output_path)
        except OSError:
            pass


if __name__ == "__main__":
    main()
